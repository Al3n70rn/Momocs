# 0. Coo (Opn/Out/Ldk) domestics -----------------------------------------------

#' Coo class
#' 
#' \code{Coo} class is a super class for \link{Opn} and \link{Out} classes,
#' \bold{open outlines} and \bold{closed outlines}, respectively.
#' 
#' It allows to recycle most of the methods, since both of them apply on
#' \eqn{(x; y)} coordinates. In other words, \code{Opn} and \code{Out} classes
#' are all, primarily, \code{Coo} objects on which we define generic \emph{and} 
#' specific methods.
#' 
#' If you used Momocs before version <1.0, or if you have read the JSS paper,
#' you are probably looking for \link{Out}.
#' 
#' More, generally, see \link{Opn} and \link{Out} for documentation on these classes.
#'
#'@param ... anything and, anyway, this function will simply returns a message.
#' @keywords Coo
#' @export
Coo <- function(...){
  cat(" * Coo constructor has been deprecated. See ?Coo")}

#' Coe class
#' 
#' \code{Coe} class is a super class for \link{OutCoe} and \link{OpnCoe} classes,
#' matrices of coefficients, along with other informations, obtained with
#' morphometrics methods on \code{\link{Out}} and \code{\link{Opn}} objects.
#' 
#' It allows to recycle most of the methods, since both of them apply on
#' matrices of coefficients. In other words, \code{OutCoe} and \code{OpnCoe}
#' classes are all, primarily, \code{Coe} objects on which we define generic 
#' \emph{and} specific methods.
#' 
#' More, generally, see \link{Opn} and \link{Out} for documentation on these classes.
#'
#' @param ... anything and, anyway, this function will simply returns a message.
#' @keywords Coe
#' @export
Coe <- function(...){
  cat(" * Coe constructor does not exist alone. See ?Coe")}

# allows to maintain the tradition str() behaviour
# actually useless but dont remember why/where
#' @export
str.Coo <- function(object, ...){
  Coo <- object
  ls.str(Coo)}
#' @export
str.Coe <- function(object, ...){
  Coe <- object
  ls.str(Coe)}

# Coo can be indexing both to [ ] and [[ ]]
# and returns the corresponding coordinate(s)
# We define some getters

#' @export
"[.Coo" <- function(x, i, ...) {
  if (missing(i))    { return(x$coo[])    }
  if (is.integer(i)) { return(x$coo[i])   }
  if (is.numeric(i)) { return(x$coo[[i]]) }}

#' @export
"[[.Coo" <- function(x, i, ...) {
  if (missing(i))    { return(x$coo[])    }
  if (is.integer(i)) { return(x$coo[i])   }
  if (is.numeric(i)) { return(x$coo[[i]]) }}

# length on an Coo return the length of Coo$coo, ie the number of coordinates
#' @export
length.Coo <- function(x) {
  Coo <- x
  return(length(Coo$coo))}
#' @export
dim.Coe <- function(x){
  return(dim(x$coe))}


# names() on a Coo retrieves the names of the Coo$coo
#' @export
names.Coo <- function(x){
  Coo <- x
  return(names(Coo$coo))}
#' @export
names.Coe <- function(x){
  Coe <- x
  return(rownames(Coe$coe))}

# which can in return may be named using names(Coo) <- 
#' @export
"names<-.Coo" <- function(x, value){
  names(x$coo) <- value
  return(x)}
#' @export
"names<-.Coe" <- function(x, value){
  rownames(x$coe) <- value
  return(x)}

#' Create subsets of Coo objects
#' 
#' Pretty useful in morphometrics. Imagine you have a \link{Out} or a \link{Opn}
#' object that combines several different \emph{groups}, 
#' whatever \emph{groups} are : species, views, etc. You may be interested in
#' doing separated analyses (even if you could combine them later), then this
#' function will ease the process. See the examples below.
#' @aliases subset
#' @S3method  subset Coo
#' @param x a \code{Coo} object, i.e. \link{Out} or \link{Opn}
#' @param subset logical taken from the $fac slot, or indices. See examples.
#' @param ... useless here but maintains consistence with the generic subset.
#' @keywords Opn Coo
#' @export
#' @examples
#' data(bot)
#' bot$fac
#' beers <- subset(bot, type=="beer")
#' whisk <- subset(bot, type=="whisky")
#' # or you may prefere indices
#' subset(bot, c(1, 13, 34, 37))
#' # and you can combine them :
#' data(olea)
#' olea$fac
#' subset(olea, domes=="cult" & view=="VL")
subset.Coo <- function(x, subset, ...){
  Coo <- x
  e <- substitute(subset)
  retain <- eval(e, Coo$fac, parent.frame())
  Coo2 <- Coo
  Coo2$coo <- Coo$coo[retain]
  if (length(Coo$ldk)>0) Coo2$ldk <- Coo$ldk[retain]
  if (ncol(Coo$fac)>0) {
    Coo2$fac <- Coo$fac
    Coo2$fac <- as.data.frame(Coo2$fac[retain, ])
    names(Coo2$fac) <- names(Coo$fac)
    Coo2$fac <- .refactor(Coo2$fac)
  }
  return(Coo2)}

# 1. Domestic functions -------------------------------------------------------------
# Placed here so far

#' Calculates euclidean distance between two points.
#' 
#' \code{ed} simply calculates euclidean distance between two points defined by
#' their (x; y) coordinates.
#' 
#' @export
#' @param pt1 (x; y) coordinates of the first point.
#' @param pt2 (x; y) coordinates of the second point.
#' @return Returns the euclidean distance between the two points.
#' @seealso \link{edm}, \link{edm.nearest}, \link{dist}.
#' @examples
#' ed(c(0,1), c(1,0))
ed <- function(pt1, pt2){return(sqrt((pt1[1]-pt2[1])^2+(pt1[2]-pt2[2])^2))}

#' Calculates euclidean intermediate between two points.
#' 
#' \code{edi} simply calculates coordinates of a points at the relative
#' distance \code{r} on the \code{pt1-pt2} defined by their (x; y) coordinates.
#' This function is used internally but may be of interest for other analyses.
#' 
#' @export edi
#' @param pt1 \eqn{(x; y)} coordinates of the first point.
#' @param pt2 \eqn{(x; y)} coordinates of the second point.
#' @param r the relative distance from \code{pt1} to \code{pt2}.
#' @return returns the \eqn{(x; y)} interpolated coordinates.
#' @seealso \link{ed}, \link{edm}.
#' @keywords domestic
#' @examples
#' edi(c(0,1), c(1,0), r = 0.5)
edi <- function(pt1, pt2, r=0.5){
  return(r*(pt2-pt1) + pt1) }

#' Calculates euclidean distance every pairs of points in two matrices.
#' 
#' \code{edm} returns the euclidean distances between points \deqn{1 -> n} of
#' two 2-col matrices of the same dimension. This function is used internally
#' but may be of interest for other analyses.
#' 
#' If one wishes to align two (or more shapes) Procrustes surimposition may
#' provide a better solution.
#' @export edm
#' @param m1 The first \code{matrix} of coordinates.
#' @param m2 The second \code{matrix} of coordinates.
#' @return Returns a \code{vector} of euclidean distances between pairwise
#' coordinates in the two matrices.
#' @seealso \link{ed}, \link{edm.nearest}, \link{dist}.
#' @keywords domestic
#' @examples
#' x <- matrix(1:10, nc=2)
#' edm(x, x)
#' edm(x, x+1)
edm            <- function(m1, m2){
  return(sqrt((m1[, 1] - m2[, 1])^2 + (m1[, 2] - m2[, 2])^2))}

#' Calculates the shortest euclidean distance found for every point of one
#' matrix among those of a second.
#' 
#' \code{edm.nearest} calculates the shortest euclidean distance found for
#' every point of one matrix among those of a second. In other words, if
#' \code{m1, m2} have \code{n} rows, the result will be the shortest distance
#' for the first point of \code{m1} to any point of \code{m2} and so on,
#' \code{n} times. This function is used internally but may be of interest for
#' other analyses.
#' 
#' So far this function is quite time consumming since it performs \deqn{ n
#' \times n } euclidean distance computation.  If one wishes to align two (or
#' more shapes) Procrustes surimposition may provide a better solution.
#' @export edm.nearest
#' @param m1 The first \code{list} or \code{matrix} of coordinates.
#' @param m2 The second \code{list} or \code{matrix} of coordinates.
#' @param full \code{logical}. Whether to returns a condensed version of the
#' results.
#' @return If \code{full} is \code{TRUE}, returns a \code{list} with two
#' components: \code{d} which is for every point of \code{m1} the shortest
#' distance found between it and any point in \code{m2}, and \code{pos} the
#' (\code{m2}) row indices of these points. Otherwise returns \code{d} as a
#' numeric vector of the shortest distances.
#' @seealso \link{ed}, \link{edm}, \link{dist}.
#' @keywords domestic
#' @examples
#' 
#' x <- matrix(1:10, nc=2)
#' edm.nearest(x, x+rnorm(10))
#' edm.nearest(x, x+rnorm(10), full=TRUE)
edm.nearest <- function(m1, m2, full=FALSE){
  if (!is.matrix(m1) | !is.matrix(m2)) stop("Matrices must be provided")
  if (ncol(m1)!=2    | ncol(m2)!=2)    stop("2-cols matrices must be provided")
  nr <- nrow(m1)
  pos <- d  <- numeric(nr)
  for (i in 1:nr){
    m1.i   <- m1[i, ]
    di     <- apply(m2, 1, function(x) sqrt(sum((x - m1.i)^2)))
    d[i]   <- min(di)
    pos[i] <- which.min(di)}
  if (full) return(list(d=d, pos=pos)) else return(d) }

# Utilities (useless?)
#'@export
.refactor <- function(df){data.frame(lapply(df, factor))}
#' @export
.trim.ext <- function(lf, width=nchar(lf)-4) {return(strtrim(lf, width=width))}
#' @export
.trim.path <- function(lf){
  lf0 <- strsplit(lf, "/")
  lf0 <- sapply(lf0, function(x) x[length(x)])
  lf0 <- substr(lf0, 1, nchar(lf0)-4)
return(lf0)}

# 00. Package documentation and NAMESPACE import ---------------------------

#' Momocs
#' 
#'
#' Morphometrics using R
#' 
#' @seealso
#' Momocs' homepage : \url{http://www.vincentbonhomme.fr/Momocs} with tutorials
#' and hotline.
#' 
#' Momocs' GitHub repo : \url{https://github.com/vbonhomme/Momocs} to contribute,
#' among other things.
#' 
#' @references Bonhomme V, Picq S, Gaucherel C, Claude J. 2014. Momocs: Outline Analysis Using R. 
#' \emph{Journal of Statistical Software} \bold{56}. \url{http://www.jstatsoft.org/v56/i13}.
#' 
#' Claude J. 2008. \emph{Morphometrics with R}. Springer-Verlag, New-York.
#' @details
#' We are very grateful to  Cedric Gaucherel, Sarah Ivorra, Ricardo Kriebel, Neus
#' Martinez, Marcelo Reginato, Evan Saitta, Norbert Telmon, Bill Venables, Asher Wishkerman for
#' their helpful contributions, ideas, bug reports, and much more.
#' @import ape
#' @import sp
#' @importFrom jpeg readJPEG
#' @importFrom shapes procGPA
#' @importFrom methods showDefault
#' @importFrom MASS ginv
#' @docType package
#' @name Momocs
#' @keywords Abtract
NULL

# 0. Datasets documentation ----------------------------------------------------
#' Data: Outline coordinates of 20 beer and 20 whisky bottles.
#' 
#' @docType data
#' @name bot
#' @rdname data_bot
#' @keywords datasets
#' @format A \link{Out} object containing the outlines coordinates and a grouping factor
#' for 20 beer and 20 whisky bottles
#' @source  Images have been grabbed on the internet and prepared by the package's
#' authors. No particular choice has been made on the dimension of the original
#' images or the brands cited here.
NULL

#' Data: Outline coordinates of 50 cephalic outlines of trilobite
#' 
#' @docType data
#' @name trilo
#' @rdname data_trilo
#' @keywords datasets
#' @format A \link{Out} object 64 coordinates of 50 cephalic outlines from different
#' ontogenetic stages of trilobite.
#' @source  Arranged from: \url{http://folk.uio.no/ohammer/past/outlines.dat}.
#' The original data included 51 outlines and 5 ontogenetic stages, 
#' but one of them has just a single outline thas has been removed.
NULL


#' Data: Outline coordinates of 126 mosquito wings.
#' 
#' @docType data
#' @name mosquito
#' @rdname data_mosquito
#' @keywords datasets
#' @format A \link{Out} object with the 126 mosquito wing outlines outlines
#' used Rohlf and Archie (1984).
#' @source Rohlf F, Archie J. 1984. A comparison of Fourier methods for the
#' description of wing shape in mosquitoes (Diptera: Culicidae). \emph{Systematic Biology}: 302-317.
#' Arranged from: \url{http://life.bio.sunysb.edu/morph/data/RohlfArchieWingOutlines.nts}.
NULL

#' Data: Outline coordinates of 240 hand-drawn hearts
#' 
#' @docType data
#' @name hearts
#' @rdname data_hearts
#' @keywords datasets
#' @format A \link{Out} object with the outline coordinates of 240 hand-drawn hearts
#' by 8 different persons, with 4 landmarks.
#' @source We thank the fellows of the Ecology Department of the French Institute
#' of Pondicherry that drawn the hearts, that then have been smoothed, scaled, centered, and degraded to 80 coordinates per outline.
NULL

#' Data: Outline coordinates of 210 olive seeds oopen outlines.
#' 
#' @docType data
#' @name olea
#' @rdname data_olea
#' @keywords datasets
#' @format An \link{Opn} object with the outline coordinates of olive seeds.
#' @source We thank Jean-Frederic Terral and Sarah Ivorra (UMR CBAE, Montpellier, France)
#' from allowing us to share the data.
#' 
#' You can have a look to the original paper:
#' Terral J-F, Alonso N, Capdevila RB i, Chatti N, Fabre L, Fiorentino G, 
#' Marinval P, Jorda GP, Pradat B, Rovira N, et al. 2004. 
#' Historical biogeography of olive domestication (\emph{Olea europaea} L.) 
#' as revealed by geometrical morphometry applied to biological and 
#' archaeological material. \emph{Journal of Biogeography} \bold{31}: 63-77.
NULL

# #' Data: Outline coordinates of 50 date seeds (Phoenix dactylifera), with 2 views
# #' 
# #' @docType data
# #' @name phoenix
# #'@rdname data_phoenix
# #' @keywords datasets
# #' @format An Out object with the outline coordinates of 50 date seeds
# #' (Phoenix dactylifera), with dorsal and lateral views
# #' @source We thank Jean-Frédéric Terral and Sarah Ivorra (UMR CBAE, Montpellier, France)
# #' from allowing us to share the data.
