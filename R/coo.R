# 1. coo utilities and their Out methods ---------------------------------------
# a family of functions that do simple functions on 2d coordinates (further
# abbreviated as "shape" (either outlines, open outlines or lanfmarks)
# they can be passed either as two-column matrices colnames ("x" and "y"
# colnaming is not mandatory) or as a list with $x and $y components.
# and returns a (named) matrix of coordinates.

#' Checks shape
#'
#' A simple utility, used internally, mostly in the coo functions and methods.
#' Returns a matrix, when passed with either a list or a matrix of coordinates.
#'
#' @param coo a matrix of (x,y) coordinates or a list.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @export coo.check
#' @examples
#' #coo.check("Not a shape")
#' #coo.check(matrix(1:10, ncol=2))
#' #coo.check(list(x=1:5, y=6:10))
coo.check <- function(coo){
  if (is.matrix(coo)) {return(coo)}
  if (is.list(coo))   {return(l2m(coo))}
  stop("A list or a matrix of (x, y) coordinates must be provided.")}

#' Centers coordinates
#'
#' Returns a shape centered on the origin.
#' 
#' @export coo.center
#' @aliases coo.center
#' @S3method coo.center default
#' @S3method coo.center Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' coo.center(matrix(1:10, ncol=2))
#' coo.center(list(x=1:5, y=6:10))
coo.center <- function(coo){UseMethod("coo.center")}
coo.center.default <- function(coo){
  coo <- coo.check(coo)
  return(apply(coo, 2, function(x) x - mean(x)))}

coo.center.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.center)
  return(Out)}

#' Scales coordinates
#'
#' Scales the coordinates by a 'scale' factor. If not provided,
#' assumed to be the centroid size. It involves three steps: centering from current position,
#' dividing coordinates by 'scale', pusing back to the original position.
#' 
#' @export coo.scale
#' @aliases coo.scale 
#' @S3method coo.scale default
#' @S3method coo.scale Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param scale numeric, the scaling factor, by default the centroid size.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.scale(bot))
#' coo.plot(bot[4])
#' coo.plot(coo.scale(bot[4]))

coo.scale <- function(coo, scale){UseMethod("coo.scale")}
coo.scale.default <- function (coo, scale=coo.centsize(coo)) {
  coo <- coo.check(coo)
  cp  <- coo.centpos(coo)
  coo <- coo.trans(coo.trans(coo, -cp[1], -cp[2])/scale, cp[1], cp[2])
  return(coo)}
coo.scale.Out <- function(coo, scale){
  Out <- coo
  #dirty loop but had bad time trying to vectorize it
  if (missing(scale)) {
    scale <- sapply(Out$coo, coo.centsize)}
  if (length(scale) != length(Out)) {
    scale <- rep(scale, length(Out))}
  for (i in seq(along=Out$coo)){
    Out$coo[[i]] <- coo.scale(Out$coo[[i]], scale[i])}
  return(Out)}

#' Rotates coordinates
#'
#' Rotates the coordinates by a 'theta' angle (in radians) If not provided,
#' assumed to be the centroid size. It involves three steps: centering from current position,
#' dividing coordinates by 'scale', pusing back to the original position.
#' 
#' @export coo.rotate
#' @aliases coo.rotate 
#' @S3method coo.rotate default
#' @S3method coo.rotate Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param theta angle in radians
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.rotate(bot, pi))
#' coo.plot(bot[4])
#' coo.plot(coo.rotate(bot[4], -pi/2))
coo.rotate <- function(coo, theta=0){UseMethod("coo.rotate")}
coo.rotate.default <- function(coo, theta=0){
  coo <- coo.check(coo)
  rmat <- matrix(c(cos(theta), sin(theta),
                   -sin(theta), cos(theta)), nrow=2)
  return(coo %*% rmat)}
coo.rotate.Out <- function(coo, theta=0){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.rotate, theta)
  return(Out)}

#' Aligns coordinates
#'
#' Aligns the coordinates along their longer axis using var-cov matrix and eigen values.
#' 
#' @export coo.align
#' @aliases coo.align 
#' @S3method coo.align default
#' @S3method coo.align Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.align(bot))
#' coo.plot(bot[4])
#' coo.plot(coo.align(bot[4]))
coo.align <- function(coo){UseMethod("coo.align")}
coo.align.default <- function(coo){
  coo <- coo.check(coo)
  return(coo %*% svd(var(coo))$u)}
coo.align.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.align)
  return(Out)}

#' Translates coordinates
#'
#' Translates the coordinatesby a 'x' and 'y' value
#' 
#' @export coo.trans
#' @aliases coo.trans 
#' @S3method coo.trans default
#' @S3method coo.trans Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param x the translation on the x dimension.
#' @param y the translation on the y dimension.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @family coo
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.trans(bot, 10, 10))
#' coo.plot(bot[4])
#' coo.plot(coo.trans(bot[4], 10, 10))
coo.trans <- function(coo, x=0, y=0){UseMethod("coo.trans")}
coo.trans.default <- function(coo, x=0, y=0){
  coo <- coo.check(coo)
  cbind(coo[, 1] + x, coo[, 2] + y) }
coo.trans.Out <- function(coo, x=0, y=0){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.trans, x, y)
  return(Out)}

#' Slides coordinates
#'
#' Slides the coordinates so that the id1-th point become the first one.
#' @export coo.slide
#' @aliases coo.slide
#' @S3method coo.slide default
#' @S3method coo.slide Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param id1 the id of the point that will become the new first point.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(hearts)
#' stack(hearts)
#' stack(coo.slide(hearts, 1))
#' coo.plot(hearts[4])
#' coo.plot(coo.slide(hearts[4], 50))
coo.slide <- function(coo, id1){UseMethod("coo.slide")}
coo.slide.default <- function(coo, id1){
  coo <- coo.check(coo)
  if (id1 == 0) {return(coo)}
  n <- nrow(coo)
  slided.rows <- c(id1:n, 1:(id1-1))
  return(coo[slided.rows, ])}
coo.slide.Out <- function(coo, id1){
  Out <- coo
  if (length(Out$ldk)==0) stop(" * No landmarks defined.")
  for (i in seq(along=Out$coo)) {
    Out$coo[[i]] <- coo.slide(Out$coo[[i]], Out$ldk[[i]][id1])
    Out$ldk[[i]] <- (Out$ldk[[i]] - (Out$ldk[[i]][id1] -1)) %% nrow(Out$coo[[i]])}
  return(Out)}

#' Sample coordinates (among points)
#'
#' Sample n coordinates among existing points
#' 
#' @export coo.sample
#' @aliases coo.sample 
#' @S3method coo.sample default
#' @S3method coo.sample Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param n an integer, the number fo points to sample.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.sample(bot, 12))
#' coo.plot(bot[4])
#' coo.plot(coo.sample(bot[4], 12))
coo.sample <- function(coo, n){UseMethod("coo.sample")}
coo.sample.default <- function (coo, n) {
  coo <- coo.check(coo)
  sampled <- round(seq(1, nrow(coo), len = n + 1)[-(n + 1)])
  return(coo[sampled, ])}
coo.sample.Out <- function(coo, n){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.sample, n)
  return(Out)}

#' Samples coordinates (regular radius)
#'
#' Samples n coordinates with a regular angle
#' 
#' @export coo.samplerr
#' @aliases coo.samplerr 
#' @S3method coo.samplerr default
#' @S3method coo.samplerr Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param n an integer, the number fo points to sample.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' bot <- coo.center(bot)
#' stack(coo.samplerr(bot, 12))
#' coo.plot(bot[4])
#' coo.plot(rr <- coo.samplerr(bot[4], 12))
#' cpos <- coo.centpos(bot[4])
#' segments(cpos[1], cpos[2], rr[, 1], rr[, 2])
coo.samplerr <- function(coo, n){UseMethod("coo.samplerr")}
coo.samplerr.default <- function(coo, n){
  coo <- coo.check(coo)
  Rx <- coo[, 1]
  Ry <- coo[, 2]
  le  <-length(Rx)
  M   <-matrix(c(Rx, Ry), le, 2)
  M1  <-matrix(c(Rx-mean(Rx), Ry-mean(Ry)), le, 2)
  V1  <-complex(real=M1[, 1], imaginary=M1[, 2])
  M2  <-matrix(c(Arg(V1), Mod(V1)), le, 2)
  V2  <-NA
  for (i in 0:(n-1)){
    V2[i+1] <- which.max((cos(M2[, 1] - 2*i*pi/n)))}
  V2 <- sort(V2)
  return(M1[V2, ])}
coo.samplerr.Out <- function(coo, n){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.samplerr, n)
  return(Out)}

#' Interpolates coordinates
#'
#' Interpolates n coordinates "among existing points"between" existing points,
#' along the perimeter of the coordinates provided and keeping the first point
#' 
#' @export coo.interpolate
#' @aliases coo.interpolate
#' @S3method coo.interpolate default
#' @S3method coo.interpolate Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param n an integer, the number fo points to interpolate.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.interpolate(coo.sample(bot, 12), 120))
#' coo.plot(bot[4])
#' coo.plot(coo.interpolate(coo.sample(bot[4], 12), 120))
coo.interpolate <- function(coo, n){UseMethod("coo.interpolate")}
coo.interpolate.default <- function(coo, n){
  coo <- coo.check(coo)
  if (!is.closed(coo)) { coo <- coo.close(coo) }
  orig <- coo.perim.cum(coo)
  targ <- seq(0, coo.perim(coo), length=n+1)[-(n+1)]
  coo2 <- matrix(c(coo[1, ], rep(NA, n*2 - 2)), byrow=TRUE, nrow=n, ncol=2)
  for (i in 2:n) {
    k <- max(which(orig <= targ[i]))
    r <- (targ[i] - orig[k]) / (orig[k+1]- orig[k])
    coo2[i, ] <- edi(coo[k, ], coo[k+1, ], r)}
  return(coo2)}
coo.interpolate.Out <- function(coo, n){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.interpolate, n)
  return(Out)}

#' Smoothes coordinates
#'
#' Smoothes coordinates using a simple moving average.
#' May be useful to remove digitization noise.
#' @export coo.smooth
#' @aliases coo.smooth
#' @S3method coo.smooth default
#' @S3method coo.smooth Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param n an integer to specify the number of smoothing iterations
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.smooth(bot, 10))
#' coo.plot(bot[4])
#' coo.plot(coo.smooth(bot[4], 30))
coo.smooth <- function(coo, n){UseMethod("coo.smooth")}
coo.smooth.default <- function(coo, n=0){
  coo <- coo.check(coo)
  p   <- nrow(coo)
  a   <- 0
  while (a < n) {
    a <- a + 1
    coo.i <- rbind(coo[-1, ], coo[1, ])
    coo.s <- rbind(coo[p, ],  coo[-p, ])
    coo   <- coo/2 + coo.i/4 + coo.s/4}
  return(coo)}
coo.smooth.Out <- function(coo, n){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.smooth, n)
  return(Out)}

#' Tests if shapes are closed
#'
#' Returns TRUE/FALSE whether the last coordinate of the shapes is the same
#' as the first one.
#' 
#' @export is.closed
#' @aliases is.closed
#' @S3method is.closed default
#' @S3method is.closed Out
#' @param coo a matrix of (x,y) coordinates or a Out object
#' @return a boolean.
#' @keywords coo_utilities
#' @examples
#' is.closed(matrix(1:10, ncol=2))
#' is.closed(coo.close(matrix(1:10, ncol=2)))

is.closed <- function(coo){UseMethod("is.closed")}
is.closed.default <- function(coo){
  coo <- coo.check(coo)
  identical(coo[1,], coo[nrow(coo),]) }
is.closed.Out <- function(coo){
  Out <- coo
  return(sapply(Out$coo, is.closed))}

# # is.likelyopen tries to estimate is a matrix of coordinates is likely to be a
# # closed polygon
# is.likelyclosedpolygon <- function(coo) {
#   x <- coo.perim.pts(coo)
#   d <- max(x) / median(x[-which.max(x)])
#   ifelse(d > 3, TRUE, FALSE)}

#' Closes/'Uncloses' shapes
#'
#' Returns a closed shape from (un)closed shapes. See also \link{coo.unclose}.
#' 
#' @export coo.close
#' @S3method coo.close default
#' @S3method coo.close Out
#' @param coo a matrix of (x,y) coordinates or a Out object
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' x <- (matrix(1:10, ncol=2))
#' x2 <- coo.close(x)
#' x3 <- coo.unclose(x2)
#' x
#' is.closed(x)
#' x2
#' is.closed(x2)
#' x3
#' is.closed(x3)
coo.close <- function(coo){UseMethod("coo.close")}
coo.close.default <- function(coo){
  coo <- coo.check(coo)
  ifelse(is.closed(coo), return(coo), return(rbind(coo, coo[1, ])))}
coo.close.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.close)
  return(Out)}

#' 'Uncloses' shapes
#'
#' Returns a unclosed shape from (un)closed shapes. See also \link{coo.close}.
#' 
#' @export coo.unclose 
#' @S3method coo.unclose default
#' @S3method coo.unclose Out
#' @param coo a matrix of (x,y) coordinates or a Out object
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' x <- (matrix(1:10, ncol=2))
#' x2 <- coo.close(x)
#' x3 <- coo.unclose(x2)
#' x
#' is.closed(x)
#' x2
#' is.closed(x2)
#' x3
#' is.closed(x3)
coo.unclose <- function(coo){UseMethod("coo.unclose")}
coo.unclose.default <- function(coo){
  coo <- coo.check(coo)
  ifelse(is.closed(coo), return(coo[-nrow(coo), ]), return(coo))}
coo.unclose.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.unclose)
  return(Out)}

# Some utilities documented yet less likely to be used. They may be useful for
# some testing, developing new methods, or on monday mornings.

#' Rotates shapes with a custom center
#'
#' rotates a shape of "theta" angles (in radians) and with a (x, y) "center".
#' @export coo.rotatecenter
#' @aliases coo.rotatecenter
#' @S3method coo.rotatecenter default
#' @S3method coo.rotatecenter Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param theta an angle, in radians.
#' @param center the (x, y) position of the center
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' coo.plot(bot[4])
#' coo.plot(coo.rotatecenter(bot[4], pi/2, c(0, 0)))
coo.rotatecenter <- function(coo, theta, center=c(0, 0)){UseMethod("coo.rotatecenter")}
coo.rotatecenter.default <- function(coo, theta, center=c(0, 0)){
  coo <- coo.trans(coo, -center[1], -center[2])
  coo <- coo.rotate(coo, theta)
  return(coo.trans(coo, center[1], center[2]))}
coo.rotatecenter.Out <- function(coo, theta, center=c(0, 0)){
  Out <- coo
  for (i in seq(along=Out$coo)){
    Out$coo[[i]] <- coo.rotatecenter(Out$coo[[i]], theta, center)}
  return(Out)}

#' Forces shapes to close
#'
#' An exotic function that distribute the distance between the first and the last points
#' of unclosed shapes, so that they become closed. May be useful (?) e.g. for t/rfourier methods
#' where reconstructed shapes may not be closed.
#' @export
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 64)
#' b <- b[1:40,]
#' coo.plot(b)
#' coo.plot(coo.force2close(b))
coo.force2close <- function(coo){
  coo <- coo.check(coo)
  if (is.closed(coo)) {return(coo)}
  n  <- nrow(coo)
  d  <- coo[1, ] - coo[n, ]
  dm <- cbind(seq(0, d[1], length=n), seq(0, d[2], length=n))
  return(coo + dm)}

# 2. Handling / baselines on coo and Out -------------------------------------
# Some functions and methods to ease alignments, grabbing part of shapes, etc.
#' Retains coordinates with positive y-coordinates
#'
#' Useful when shapes are aligned along the x-axis (e.g. because of a 
#' bilateral symmetry) #' and when one wants to retain just the upper side. 
#' @export coo.up
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- coo.align.xax(bot[4])
#' coo.plot(b)
#' coo.plot(coo.up(b))

coo.up <- function(coo){
  up <- coo[coo[,2]>=0,]
  return(up)}

#' Retains coordinates with negative y-coordinates
#'
#' Useful when shapes are aligned along the x-axis (e.g. because of a 
#' bilateral symmetry) and when one wants to retain just the lower side. 
#' @export coo.down
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- coo.align.xax(bot[4])
#' coo.plot(b)
#' coo.plot(coo.down(b))
coo.down <- function(coo){
  coo <- coo.check(coo)
  return(coo[coo[, 2]<=0,])}

#' Aligns shapes along the x-axis
#' Align the longest axis of a shape along the x-axis
#' @export coo.align.xax
#' @aliases coo.align.xax
#' @S3method coo.align.xax default
#' @S3method coo.align.xax Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- bot[4]
#' coo.plot(b)
#' coo.plot(coo.align.xax(b))

coo.align.xax <- function(coo){UseMethod("coo.align.xax")}
coo.align.xax.default <- function(coo){
  coo <- coo.check(coo)
  coo <- coo.align(coo)
  return(coo.trans(coo, x=0, y=- coo.centpos(coo)[2]))}

coo.align.xax.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.align.xax)
  return(Out)}

#' Aligns shapes along their calliper length
#' And returns them registered on bookstein coordinates.
#' See \link{coo.bookstein}.
#' @export coo.align.calliper
#' @aliases coo.align.calliper
#' @S3method coo.align.calliper default
#' @S3method coo.align.calliper Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- bot[4]
#' coo.plot(b)
#' coo.plot(coo.align.calliper(b))
#' \dontrun{ #todo olea
#' bot.al <- coo.align.calliper(bot)
#' stack(bot.al)
#' }

coo.align.calliper <- function(coo){UseMethod("coo.align.calliper")}
coo.align.calliper.default <- function(coo){
  coo <- coo.check(coo)
  cal.ind <- coo.calliper(coo, arr.ind=TRUE)$arr.ind
  coo <- coo.bookstein(coo, cal.ind[1], cal.ind[2])
  return(coo)}

coo.align.calliper.Out <- function(coo){
  Out <- coo
  Out$coo <- lapply(Out$coo, coo.align.calliper)
  return(Out)}

#' Reverses coordinates
#' 
#' Returns the reverse suite of coordinates, i.e. change shape's orientation
#' @export
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 4)
#' b
#' coo.rev(b)
coo.rev <- function(coo){
  coo <- coo.check(coo)
  return(coo[nrow(coo):1,])}

#' Defines interactively landmarks
#' Allows to interactively define a "nb.ldk" number of landarks on a shape.
#' Used in other facilities to acquire/manipulate data.
#' @export coo.ldk
#' @aliases coo.ldk
#' @param coo a matrix or a list of (x,y) coordinates.
#' @param nb.ldk integer, the number of landmarks to define
#' @return a numeric that corresponds to the closest ids,
#' on the shape, from cliked points.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 4)
#' # coo.ldk(b, 3) # run this, and click 3 times.
coo.ldk <- function(coo, nb.ldk) {
  if (is.list(coo)) coo <- l2m(coo)
  coo.plot(coo)
  ldk <- numeric(nb.ldk)
  cat("[")
  for (i in 1:nb.ldk){
    p <- l2m(locator(1))
    l <- apply(coo, 1, function(y) sqrt(sum((p-y)^2)))
    ldk[i] <- which.min(l)
    points(coo[ldk[i], 1], coo[ldk[i], 2], pch=20, col="red", cex=0.5)
    cat("*")}
  cat("]\n")
  return(ldk)}

#' Register Bookstein's coordinates
#'
#' Registers a new baseline for the shape, with the ldk1-th
# and ldk2-th points being set on (-0.5, 0) and (0.5, 0), respectively.
#' @export coo.bookstein
#' @aliases coo.bookstein
#' @S3method coo.bookstein default
#' @S3method coo.bookstein Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param ldk1 the id of the first point of the new baseline
#' @param ldk2 the id of the second point of the new baseline
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(hearts)
#' stack(hearts)
#' stack(coo.bookstein(hearts, 2, 4))
coo.bookstein <- function(coo, ldk1, ldk2){UseMethod("coo.bookstein")}
coo.bookstein.default <- function(coo, ldk1, ldk2){
  D <- ed(coo[ldk1, ], coo[ldk2, ])
  coo2 <- matrix(NA, nrow(coo), ncol(coo))
  ldk1 <- coo[ldk1,]
  ldk2 <- coo[ldk2,]
  coo2[, 1] <- (((ldk2[1]-ldk1[1]) * (coo[,1]-ldk1[1])
                 + (ldk2[2]-ldk1[2]) * (coo[,2]-ldk1[2])) / (D^2)) - 0.5
  coo2[, 2] <- ((ldk2[1]-ldk1[1])  * (coo[,2]-ldk1[2])
                - (ldk2[2]-ldk1[2])  * (coo[,1]-ldk1[1])) / (D^2)
  return(coo2)}
coo.bookstein.Out <- function(coo, ldk1, ldk2){ #id1 ?
  Out <- coo
  for (i in seq(along=Out$coo)){
    Out$coo[[i]] <- coo.bookstein(Out$coo[[i]], Out$ldk[[i]][ldk1], 
                                  Out$ldk[[i]][ldk2])}
  return(Out)}

#' Register new baselines
#'
#' A non-exact baseline registration on t1 and t2 coordinates,
#' for the ldk1-th and ldk2-th points.
#' By default it returns Bookstein's coordinates.
#' @export coo.baseline
#' @aliases coo.baseline
#' @S3method coo.baseline default
#' @S3method coo.baseline Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @param ldk1 the id of the first point of the new baseline
#' @param ldk2 the id of the second point of the new baseline
#' @param t1 numeric the (x,y) coordinates of the 1st point of the new baseline
#' @param t2 numeric the (x,y) coordinates of the 2nd point of the new baseline
#' @return a matrix of (x,y) coordinates or an Out object.
#' @keywords coo_utilities
#' @examples
#' data(hearts)
#' stack(hearts)
#' # note the scale
#' stack(coo.baseline(hearts, 2, 4, c(-1, 0), c(1, 0)))
coo.baseline <- function(coo, ldk1, ldk2, t1, t2){UseMethod("coo.baseline")}
coo.baseline.default <- 
  function(coo, ldk1=1, ldk2=2, t1=c(-0.5, 0), t2=c(0.5, 0)){
  if (is.list(coo)) {coo <- l2m(coo)}
  t1x <- t1[1]
  t1y <- t1[2]
  t2x <- t2[1]
  t2y <- t2[2]
  r1x <- coo[ldk1, 1]
  r1y <- coo[ldk1, 2]
  r2x <- coo[ldk2, 1]
  r2y <- coo[ldk2, 2]
  # translation based on the first landmark
  ref <- coo.trans(coo, t1x - coo[ldk1, 1] , t1y - coo[ldk1, 2])
  # we calculate dx and dy for the two vectors
  rx <- ref[ldk2, 1] - t1x
  ry <- ref[ldk2, 2] - t1y 
  tx <- t2x - t1x
  ty <- t2y - t1y
  # returns difference angle and norm ratios between two vectors given as 4 numeric.
  vecs.param <- function(r1, i1, r2, i2){
    x <- c(r1, i1, r2, i2)
    r.norms <- sqrt((r2^2 + i2^2)) / sqrt((r1^2 + i1^2))
    d1 <- sqrt(sum(r1^2 + i1^2))
    d2 <- sqrt(sum(r2^2 + i2^2))
    return(list(r.norms=d1/d2, d.angle=atan2(i2, r2) - atan2(i1, r1)))}
  vi <- vecs.param(rx, ry, tx, ty)
  # we rotate accordingly with a center defined
  # as the first landmark (trans, rot, untrans)
  ref <- coo.trans(ref, -t1x, -t1y)
  ref <- ref / vi$r.norms
  ref <- coo.rotate(ref, -vi$d.angle)
  ref <- coo.trans(ref, t1x, t1y)
  return(ref)}
coo.baseline.Out <- function(coo, ldk1=1, ldk2=2, t1=c(-0.5, 0), t2=c(0.5, 0)){
  Out <- coo
  for (i in seq(along=Out$coo)){
    Out$coo[[i]] <- coo.baseline(Out$coo[[i]], Out$ldk[[i]][ldk1],
                                 Out$ldk[[i]][ldk2], t1, t2)}
  return(Out)}

# 3. coo shape descriptors -----------------------------------------------------
# Mainly intended for traditional morphometrics.
# Convert to methods ? Or an utility to get these descriptors ? #todo


# a. centroid -------------------------------------------------------------
#' Returns the position of the centroid
#'
#' Returns the (x, y) centroid coordinates of a shape.
#' @export coo.centpos
#' @aliases coo.centpos
#' @S3method coo.centpos default
#' @S3method coo.centpos Out
#' @param coo a matrix or a list of (x,y) coordinates or an Out object.
#' @return a numeric or a matrix of (x,y) coordinates.
#' @keywords coo_utilities
#' @examples
#' data(bot)
#' stack(bot)
#' stack(coo.smooth(bot, 10))
#' coo.plot(bot[4])
#' coo.plot(coo.smooth(bot[4], 30))
# coo.centpos returns the (x, y) centroid coordinates of a shape.
coo.centpos <- function(coo){UseMethod("coo.centpos")}
coo.centpos.default <- function(coo){
  coo <- coo.check(coo)
  return(apply(coo, 2, mean))}
coo.centpos.Out <- function(coo){
  Out <- coo
  centpos <- t(sapply(Out$coo, coo.centpos))
  colnames(centpos) <- c("x", "y") # pure cosmetics
  return(centpos)}

#' Calculates the centroid size
#' @export coo.centsize
#' @aliases coo.centsize
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the centroid size.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.centsize(bot[4])
#' hist(sapply(bot$coo, coo.centsize), breaks=10)
coo.centsize <- function(coo){
  coo  <- coo.check(coo)
  cent <- coo.centpos(coo)
  cs   <- mean(apply(coo, 1, function(x) sqrt(sum((x-cent)^2))))
  return(cs)}

#' Returns the distance between everypoints and the centroid
#' For every point of the shape, returns the (centroid-points) distance.
#' @export coo.centdist
#' @aliases coo.centdist
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x,y) coordinates.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 64)
#' d <- coo.centdist(b)
#' barplot(d)
coo.centdist <- function(coo){
  coo <- coo.check(coo)
  return(apply(coo, 1, function(x) ed(coo.centpos(coo), x)))}


# b. length(s) -----------------------------------------------------------------

#' Calculates the (cumulative) distance between every points of a shape.
#'
#' Calculates the euclidean distance between every points of a shape for coo.perim.pts.
#' The cumulative sum for coo.perim.cum
#' @export coo.perim.pts
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric with every distance for coo.perim.pts.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 24)
#' coo.perim.pts(b)

coo.perim.pts <-  function (coo){
  coo <- coo.check(coo)
  n <- nrow(coo)
  d <- sqrt(apply((coo - coo.slide(coo, n))^2, 1, sum))[-1]
  return(d)}

#' Calculates the cumulative distance between every points of a shape.
#'
#' Just a wrapper for cumsum(coo.perim.pts). See \link{coo.perim.pts}.
#' @export coo.perim.cum
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return numeric the cumulated sum for coo.perim.pts.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 24)
#' coo.perim.cum(b)
coo.perim.cum <- function(coo){
  coo <- coo.check(coo)
  d <- cumsum(sqrt(apply((coo-rbind(coo[1,],coo[-(dim(coo)[1]),]))^2,1,sum)))
  return(d)}

#' Calculates the perimeter
#' @export coo.perim
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the perimeter.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.perim(bot[4])
#' hist(sapply(bot$coo, coo.perim), breaks=10)
coo.perim <- function(coo){
  return(sum(coo.perim.pts(coo)))}

#' Calculates the calliper length
#' 
#' Also called the Feret's diameter, the longest distance between two points of
#' the shape provided.
#' @export coo.calliper
#' @aliases coo.calliper
#' @param coo a matrix or a list of (x,y) coordinates.
#' @param arr.ind a boolean, if provided returns a list with the calliper length ($length) 
#' and the two points ($arr.ind)
#' @return a numeric, the centroid size.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- bot[4]
#' coo.calliper(b)
#' p <- coo.calliper(b, arr.ind=TRUE)
#' p$length
#' ids <- p$arr.ind
#' coo.plot(b)
#' segments(b[ids[1], 1], b[ids[1], 2], b[ids[2], 1], b[ids[2], 2], lty=2)

coo.calliper <- function(coo, arr.ind=FALSE){
  coo <- coo.check(coo)
  d   <- dist(coo, method = "euclidean")
  # we check if there is no ex aequo
  ea <- length(which(d==max(d), arr.ind=TRUE))
  if (length(ea)>1) {cat(" * coo.length: at least two lengths are ex aequo.")}
  if (arr.ind) {
    arr.ind <- which(as.matrix(d)==max(d), arr.ind=TRUE)
    # to return a vector (numeric and sorted) of the rows between which the max
    # length has been found
    arr.ind <- sort(as.numeric(arr.ind[1, ]))
    return(list(length=max(d), arr.ind=arr.ind))
  } else {
    return(max(d))}}

#todo: bouding box
#todo: based on svd cov mat
#' Calculates length and width
#' 
#' Returns the length and width of a shape based on their iniertia axis
#' i.e. alignment to the x-axis. The length is defined as
#' the range along the x-axis; the width as the range on the y-axis.
#' @export coo.lw
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return two numeric, the length and the width.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.area(bot[4])
#' 
coo.lw <- function(coo){
  coo <- coo.check(coo)
  d   <- apply(coo.align(coo), 2, range)
  return(abs(d[2,] - d[1,]))}

# c. area ----------------------------------------------------------------------
#todo other methods to calculate area
#todo source the algo
#' Calculates the area
#' 
#' Calculates the area for any non-crossing polygon.
#' @export coo.area
#' @aliases coo.area
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the area.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.area(bot[4])
#' hist(sapply(bot$coo, coo.area), breaks=10)
coo.area <- function(coo){
  coo <- coo.check(coo)
  coo <- coo.close(coo)
  nr <- nrow(coo)-1
  y <- x <- numeric(nr)
  for (i in 1:nr){
    x[i] <- coo[i, 1] * coo[i+1, 2]
    y[i] <- coo[i+1 , 1] * coo[i, 2]
  }
  area <- (0.5 * (sum(x) - sum(y)))
  return(area)}

#' The angle formed by three points.
#' 
#' Returns the angle (in radians) defined by a triplet of points
# either signed ("atan2") or not ("acos").
#' @export coo.theta3
#' @param m a 3x2 matrix of 3 points (rows) and (x; y) coordinates
#' @param method one of "atan2" or "acos" for a signed or not angle.
#' @return numeric the angle in radians.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 64)
#' b <- b[c(1, 14, 24), ]
#' coo.plot(b)
#' coo.theta3(b)
#' coo.theta3(b, method="acos")
coo.theta3 <- function(m, method=c("atan2", "acos")[1]){  
  a <- c(m[1, 1] - m[2, 1], m[1, 2] - m[2, 2])
  b <- c(m[3, 1] - m[2, 1], m[3, 2] - m[2, 2])
  if (method=="atan2") {
    return(atan2 (a[1]*b[2]-a[2]*b[1],a[1]*b[1]+a[2]*b[2]))}
  if (method=="acos") {
    return(acos(sum(a*b)/(sqrt(sum(a*a)) * sqrt(sum(b*b)))))}}

#' The angle of every edge of a shape
#' 
#' Returns the angle (in radians) of every edge of a shape,
# either signed ("atan2") or not ("acos"). A wrapper for \link{coo.theta3}
#' @export coo.theta.pts
#' @param coo a matrix or a list of (x,y) coordinates.
#' @param method one of "atan2" or "acos" for a signed or not angle.
#' @return numeric the angles in radians for every edge.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 64)
#' coo.theta.pts(b)
coo.theta.pts <- function(coo, method=c("atan2", "acos")[1]){
  coo <- coo.check(coo)
  coo <- coo.close(coo)
  coo   <- rbind(coo[nrow(coo)-1, ], coo)
  theta <- numeric()
  for (i in 1:(nrow(coo)-2)){
    theta[i] <- coo.theta3(coo[i:(i+2),], method=method)}
  return(theta)}


# d. Scalar shape descriptors used in traditional morphometrics -------------------

#' Calculates the rectilinearity of a shape
#' 
#' As proposed by by Zunic and Rosin
#' @export  coo.rectilinearity
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the rectilinearity
#' @note due to the laborious nature of the algorithm (in nb.pts^2), 
#' and of its implementation, it may be very long to compute.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' b <- coo.sample(bot[4], 32)
#' coo.rectilinearity(b)

coo.rectilinearity <- function(coo) {
  # some check
  coo <- coo.check(coo)
  if (is.closed(coo)) {
    coo.c <- coo
    coo   <- coo.unclose(coo)
  } else {
    coo.c <- coo.close(coo)}
  # we deduce it for the algo
  n <- nrow(coo)
  k <- 4*n
  # here starts the computation as given by Zunic and Rosin
  # we calculate l1 and l2 for every edge
  l1 <- function(x1, y1, x2, y2) { abs(x1 - x2) + abs(y1 - y2) }
  l2 <- function(x1, y1, x2, y2) { sqrt((x1 - x2)^2 + (y1 - y2)^2) }
  # l2 is redefined here for coherence with the paper, but is equivalent to coo.perim.pts(coo)
  l2.e <- l1.e <- numeric(n)
  for (i in 1:n){
    x1 <- coo.c[i,   1]
    y1 <- coo.c[i,   2]
    x2 <- coo.c[i+1, 1]
    y2 <- coo.c[i+1, 2]
    l1.e[i] <- l1(x1, y1, x2, y2)
    l2.e[i] <- l2(x1, y1, x2, y2)} # sum(l2.e) == coo.perim(coo)
  # "step 1" as in Zunic and Rosin
  theta   <- coo.theta.pts(coo)
  theta.k <- abs(c(theta - pi/2, theta - pi, theta - 3*pi/2, theta - 2*pi))
  alpha.k <- sort(theta.k)
  # "step 2" as in Zunic and Rosin
  P1.Pa <- numeric(k)
  for (j in 1:k){
    P1.Pa_n <- numeric(n)
    for (i in 1:n) {
      cos.ij <- cos(theta[i] + alpha.k[j])
      sin.ij <- sin(theta[i] + alpha.k[j])  
      a.ij <- ifelse(cos.ij > 0, l2.e[i], -l2.e[i])
      b.ij <- ifelse(sin.ij > 0, l2.e[i], -l2.e[i]) 
      P1.Pa_n[i] <- a.ij*cos.ij + b.ij*sin.ij
    }
    P1.Pa[j] <- sum(P1.Pa_n)
  }
  # "step 3" as in Zunic and Rosin
  return((4/(4 - pi)) * ((sum(l2.e) / min(P1.Pa)) - (pi/4)))}

#' Calculates the Haralick's circularity of a shape
#' 
#' Returns Haralick's circularity which is less sensible
#' to digitalization noise than coo.circularity. See ...#todo
#' @export coo.circularity.haralick
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the Haralick's circularity.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.circularity.haralick(bot[4])
coo.circularity.haralick <- function(coo) {
  cd <- coo.centdist(coo)
  return(mean(cd)/sd(cd))}

#' Calculates the circularity of a shape
#' 
#' Returns the "circularity measure". Also called compactness
# and shape factor.
#' @export coo.circularity
#' @aliases coo.compactness coo.shapefactor
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the circularity.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.circularity(bot[4])

coo.circularity <- function(coo) {
  return(coo.perim(coo)^2 / coo.area(coo))}

#' Calculates the "normalized" circularity of a shape
#' 
#' Returns the "circularity", also called compactness
# and shape factor, but normalized to the unit circle.
#' @export coo.circularity.norm
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the circularity normalized to the unit circle.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.circularity.norm(bot[4])

# coo.circularity.norm returns the circularity, normalised to the unit circle.
coo.circularity.norm <- function(coo) {
  return(coo.perim(coo)^2 / (coo.area(coo)*4*pi))}

# scale dependent... #todo
# coo.fracdim <- function(coo){
#   return((2*log(coo.perim(coo))) / log(coo.area(coo)))}
#coo. <- function(coo){UseMethod("coo.")}


#' Returns the eccentricity (eigenvalues) of a shape
#' 
#' Calculated using a ratio of the eigen values (inertia axis)
#' @export coo.eccentricity.eigen
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the eccentricity (eigenvalues)
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.eccentricity.eigen(bot[4])
coo.eccentricity.eigen <- function(coo){
  coo <- coo.check(coo)
  eig <- eigen(cov(coo))$values
  return(eig[2]/eig[1])}

#' Calculates the eccentricity (bounding box) of a shape
#' 
#' Calculated using the width / length ratio. See \link{coo.lw}
#' @export coo.eccentricity.boundingbox
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the eccentricity (boundingbox)
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.eccentricity.boundingbox(bot[4])
coo.eccentricity.boundingbox <- function(coo){
  coo <- coo.check(coo)
  lw <- coo.lw(coo)
  return(lw[2]/lw[1])}

#' Calculates the elongation of a shape
#' 
#' @export coo.elongation
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the circularity normalized to the unit circle.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.elongation(bot[4])
coo.elongation <- function(coo){
  coo <- coo.check(coo)
  lw <- coo.lw(coo)
  return(1 - lw[2]/lw[1])}

#' Calculates the rectangularity of a shape
#' 
#' @export coo.rectangularity
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the rectangularity.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.rectangularity(bot[4])
coo.rectangularity <- function(coo){
  coo <- coo.check(coo)
  abr <- prod(coo.lw(coo))
  return(coo.area(coo)/abr)}

#' Calculates the convex hull of a shape
#' 
#' Returns the ids of points that define the convex hull of a shape.
#' @export coo.chull
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a matrix of (x; y) coordinates defining the convex hull of the shape.
#' @keywords coo_descriptors
#' @examples
#' data(hearts)
#' h <- coo.sample(hearts[4], 32)
#' coo.plot(h)
#' ch <- coo.chull(h)
#' lines(ch, col="red", lty=2)
coo.chull <- function(coo){
  coo <- coo.check(coo)
  return(coo[chull(coo),])}

#' Calculates the convexity of a shape
#' 
#' Calculated using a ratio of the eigen values (inertia axis)
#' @export coo.convexity
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the convexity.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.convexity(bot[4])
coo.convexity <- function(coo){
  coo <- coo.check(coo)
  return(coo.perim(coo.chull(coo))/coo.perim(coo))}

#' Calculates the solidity of a shape
#' 
#' Returns the ids of points that define the convex hull of a shape.
#' @export coo.solidity
#' @param coo a matrix or a list of (x,y) coordinates.
#' @return a numeric, the solidity of a shape.
#' @keywords coo_descriptors
#' @examples
#' data(bot)
#' coo.solidity(bot[4])
coo.solidity <- function(coo){
  coo <- coo.check(coo)
  return(coo.area(coo)/coo.area(coo.chull(coo)))}

