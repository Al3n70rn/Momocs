---
title: "Introduction to Momocs"
author: "Vincent Bonhomme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
#output: [html_document, pdf_document]
vignette: >
  %\VignetteIndexEntry{Introduction to Momocs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Momocs' speed-dating
Momocs aims to provide a complete and convenient toolkit for morphometrics. It is intended for scientists interested in describing quantitatively the shape, and its variations, of the objects they study.

In the last decade, R has become the open-source lingua franca for statistics, and morphometrics known its so-called 'revolution'. Nevertheless, morphometric analyses still have to be carried out using various software packages, for which source code is mostly unavailable or copyrighted. Moreover, most of existing software packages cannot be extended and their bugs are hard to detect and thus correct. This situation is detrimental to morphometrics; time is wasted, analyses are restricted to available methods, and last but not least, are poorly reproducible. This impedes collaborative effort both in software development and in morphometric studies.

By gathering the common morphometric approaches in an open-source environment and welcoming contributions, Momocs is an (work-in-progress) attempt to solve this twofold problem and to push morphometrics one step further.

It hinges on the core functions published in the must-have _[Morphometrics with R](http://www.springer.com/statistics/life+sciences,+medicine+%26+health/book/978-0-387-77789-4)_ by [Julien Claude](http://www.isem.univ-montp2.fr/recherche/equipes/biologie-du-developpement-et-evolution/personnel/claude-julien/) (2008), but has been further extended to allow other shape description systems. So far, configurations of landmarks, outlines and open outline analyses, along with some facilities for traditional morphometrics have been implemented.

Prior to analysis, Momocs can be used to acquire and manipulate data or to import/export from/to other formats. Momocs also has the facility for a wide range of multivariate analyses and production of the companion graphics. Thus a researcher will find that just a few lines of code will provide initial results, but the methods implemented can be finely tuned and extended according to the user's needs.

* See Momocs [features](https://github.com/vbonhomme/Momocs/#features).
* If you use it, cite it: `citation("Momocs")`.
* This citation refers to an obsolete version of Momocs, only handling outline analyses. The next one is in preparation.

## Survival tips
* This vignette gently introduces Momocs; more specific help can be find in function's helfiles, for instance `?efourier`.
* There is an online (and much nicer) version of this manual that can be accessed with `Momocs_help("efourier")`.
* Feel free to contribute to Momocs through [GitHub](http://www.github.com/vbonhomme/Momocs): report issues, ask for new features, share data and methods, correct typos, write better vignettes, helpfiles, or whatever pleases you. If you have never heard of GitHub, that's definitely worth [a look](http://r-pkgs.had.co.nz/git.html).
* Feel free to drop me a line, should you need a hand or would like to collaborate with me:   `bonhomme.vincent@gmail.com`.

## Get, install and use it
```{r, echo=FALSE}
library(knitr)
opts_chunk$set(eval = FALSE)
```

First, of all, let's download the last version of Momocs. You will need to install the `devtools` package to get it from my [GitHub](http://www.github.com/vbonhomme) repository :

```{r, eval=FALSE}
install.packages("devtools")
devtools::install_github("vbonhomme/Momocs")
```

The typical `install_packages("Momocs")` is not recommended as Momocs is still under active development, not compatible with frequent, time-consuming, and overall boring CRAN submission.

We can start using Momocs, as long as it has been loaded with :

```{r, eval=TRUE, echo=TRUE, message=FALSE}
library(Momocs)
```

## Design
Keywords used all accross Momocs are introduced here in __bold__.

Morphometrics is the ugly job of turning beautiful shapes into quantitative variables. Just kidding, that's pretty exciting.

A __shape__ is defined as a collection of `(x; y)` coordinates. No 3D yet but different __families__ can be handled: __outlines__, here in a first-quarter moon ; __open outlines__, here is the sterile valve of an olive stone; __configuration of landmarks__; here, hologous points from a mosquito wing.

```{r, echo=FALSE, message=FALSE}
shapes[18] %>% coo_sample(60) %>% coo_plot(points=TRUE)
olea[11] %>% coo_sample(32) %>% coo_plot(points=TRUE)
wings[1] %>% coo_plot(points=TRUE)
```

They are all single shapes defined by a matrix of `(x; y)` coordinates; here are the first points of the moon:
```{r, echo=FALSE}
shapes[18] %>% head()
```
A few dozens of operations on single shapes are implemented such as: plotting, centering, calculating areas, etc. They can be accessed with `apropos("coo_")`. But working on single shapes is quite boring.

Shapes can be organized into a __collection__ of coordinates: a `Coo` object that carries:

* always, a component named `$coo`, a `list` of shapes (as `matrix`.ces);
* most of the time, a component named `$fac`, a `data.frame`;
* possibly, other components of interest (thier inventory can be accessed with `ls()`).

One can do several things with a `Coo` object: visualize it, apply morphometric operations, handle the data it contains, but in the end, a __ morphometric method__ to turn coordinates into coefficients.

Morphometrics on coordinates produce a collection __collections__ of coefficients: a `Coe` objects that carries:

* always, a component named `$coe`, a `matrix` of coefficients;
* if present in `Coo`, `$fac` is copied;
* possibly, other components of insterest (their inventory can be accessed with `ls()`).

This can be summarized as follows:

`Coo`                      | + | Morphometric method  | = | `Coe`
---------------------------|----|----------------------|----|---------------
`(x;y)` coordinates        | +  | appropriate method   | =  |quantitative variables


Thus `Coo` objects are collections of coordinates that become `Coe` objects when an appropriate morphometric method is applied on them.

The different families of shape sometimes implies or requires particular operations on them. Some operations on shapes are __generic__ in that they do not depend of the family. For instance, centering a configuration of landmarks or an outline, or calculating their centroid size is, mathematically, the same __generic__ operation. But some operations on shapes are __specific__ to a peculiar family. For instance, calculating elliptical Fourier transforms on a configuration of landmarks makes no sense. 

Momocs implement this desirable behavior and defines __classes__ and __subclasses__, as S3 objects.

`Coo`                                | Morphometrics methods              | `Coe`  
-------------------------------------|------------------------------------|----------  
`OutCoo` (outlines)                  | `efourier`, `rfourier`, `tfourier` | `OutCoe`
`OpnCoo` (open outlines)             | `npoly`, `opoly`, `dfourier`       | `OpnCoe`  
`LdkCoo` (configuration of landmarks)|`fgProcrustes`, `slide`             | `LdkCoe`

In other words:
 
  * any collection of shapes belong to: primarily (pick one) `{OutCoo, OpnCoo, LdkCoo}`; and `Coo` classes
  * generic and specific methods (typically morphometrics methods) can be applied to it
  * it results in a collection of coefficients that belong to: primarily (pick one) `{OutCoe, OpnCoe, LdkCoe}`; and `Coe` classes

Finally, generic and specific operations can be applied to the `Coe` objects, chiefly multivariate methods, capitalicized: `PCA`, `LDA`, `CLUST`, `MANOVA`, etc.

Overall, Momocs implements a simple and consistent grammar that is detailed below. 

Last but not least, if you're familiar with modern R and the Hadley-verse, you should feel home as `ggplot2` graphics, `dplyr` verbs and `magrittr` pipes are implemented available.

## Basic shape operations
Let's load one of the Momocs datasets, some various outlines (an `Out` object):

```{r}
shapes                    # prints a brief summary
panel(shapes, names=TRUE) # base graphics
panel2(shapes)            # ggplot2 graphics
```

`shapes` is one of the datasets bundled with Momocs. It's ("lazy") loaded in memory as soon as you call it, no need for `data(shapes)`. To see all Momocs' datasets, try `data(package="Momocs")`. These datasets are all `Coo` objects, ie collection of shapes. One can do many things on a `Coo` object, as above, eg printing a summary of it (just by typing its name), plotting a family picture with `panel` or `panel2`. Note the `2` that refers to a `ggplot2` variant of a given plot.

So far, we're interested in single shapes so 
let's extract the 4th shape from `shapes`, using the traditional syntax.  We plot it with `coo_plot` that comes with several options for plotting all families of shapes.

```{r}
shp <- shapes[4]
coo_plot(shp) # base plotter for shapes
coo_plot(shp, col="grey80", border="black")
```

Let's now do some basic operations on this shape. They all named `coo_*` and you can have the full list with `apropos("coo_")`. `coo_*` family encompasses geometric operations (such as centering, scaling, etc.), scalar descriptors of shape (such as area, perimeter, circularity, rectilinearity, etc.) and various other operations on a single shape.

```{r}
library(maggritr)
coo_plot(coo_center(shp))
coo_plot(coo_sample(shp, 64), points=TRUE, pch=20)
```
The most common function also work on the `Coo` objects, e.g. `shapes`. Have a look to Momocs' architecture; you can start there: `?Coo`.

Also, using [maggritr](http://cran.r-project.org/package=magrittr)'s pipe operator makes things clearer: it saves typing and reads from left to right. `magrittr`'s pipes are already loaded with Momocs.

```{r}
shapes[4] %>% coo_smooth(5) %>% coo_sample(64) %>% coo_scale() %>% coo_plot()
cs64 <- function(x) x %>% coo_sample(64) %>% coo_scale() %>% coo_center()
shapes[4] %>% cs64 %>% coo_plot() # note the axes
```

## Outline analysis
__Work in progess__

You can extract outlines from a list of jpg images with `import_jpg`. Have a look to helpfiles (`import_jpg` and `import_jpg1`) for more details. Here we do not bother with import since we will use the `bot`tles dataset bundled with Momocs.

```{r}
data(bot)
bot
panel(bot, fac="type", names=TRUE)
stack(bot)
````

Just for the record, pipes can also be defined on `Coo` objects
```{r}
bot %>% 
  coo_align() %>% 
  coo_center() %>% 
  coo_scale() %>% 
  coo_slidedirection("S") %>%
  stack()
```

Let's do some EFT (but `rfourier` and `tfourier` work the same way). The idea behind elliptical Fourier transforms:
```{r}
coo_oscillo(bot[1], "efourier")
```

Let's calibrate the number of harmonics required.
```{r}
calibrate_harmonicpower(bot)
calibrate_deviations(bot)
calibrate_reconstructions(bot)
````

10 harmonics seem a nice choice, they gather 99% of the harmonic power. If you're happy with this criteria, you can even omit `nb.h` in `efourier` : that's the default parameter.

```{r}
bot.f <- efourier(bot, nb.h=10)
bot.f
```

`bot.f` is a `Coe` object (and even an `OutCoe`), you have have a look to the help files to go deeper into Momocs classes.

Let's have a look to the amplitude of fitted coefficients. We can also reconstruct fitted outlines, directly.
```{r}
hist(bot.f, drop=0)
boxplot(bot.f, drop=1)
stack(bot.f)
```

Normalize: before or after?
```{r}
data(molars)
stack(molars)
mol.al <- fgProcrustes(molars)
stack(mol.al)
panel(mol.al, fac="type")
stack(coo_slidedirection(mol.al, "W"))
plot(PCA(efourier(molars)), "type")
plot(PCA(efourier(mol.al, norm=FALSE)), "type")
```

## Multivariate statistics
__Work in progess__

Let's see the main components of shape variability with a Principal Component Analysis.

```{r}
bot.p <- PCA(bot.f)
plot(bot.p)
````

See morphological spaces are reconstructed on the flow. We can also display are two groups (defined in the slot `$fac`, here `bot$fac`).
```{r}
plot(bot.p, 1)
plot(bot.p, 1, palette=col_sari, ellipses=TRUE, ellipsesax = FALSE)
plot(bot.p, 1, pch=c(4, 5))
plot3(bot.p)

plot2(bot.p, "type") # on their way
PCcontrib(bot.p)
```

We can also calculate a Linear Discriminant Analysis on the scores. Cross-validation is also calculated and can be plotted as well.
```{r}
bot.l <- LDA(bot.p, 1)
bot.l # along with the cross-validation table. classification 
plot_CV(bot.l)
```

We can also test for a difference in the distribution of those PC scores with a multivariate ANOVA:
```{r}
MANOVA(bot.p, "type")
```

A hierarchical classification now
```{r}
CLUST(bot.p, 1)
```

We can retrieve the mean shapes:
```{r}
bot.ms <- mshapes(bot.f, 1)
beer   <- bot.ms$shp$beer
whisky <- bot.ms$shp$whisky 
tps_grid(beer, whisky)
tps_arr(beer, whisky)
tps_iso(beer, whisky)
```

And even export the coefficients.
```{r, eval=FALSE}
export(bot.f)
```

## Open outlines
__Work in progess__

```{r}
data(olea)
stack(olea)
panel(olea, names=TRUE)
op <- opoly(olea)
plot(PCA(op), ~domes+cep, palette=col_india)
```

## Configuration of landmarks
__Work in progess__

Landmarks methods are being implemented in Momocs (as of nov 2015). Full generalized Procrustes methods are available, and sliding methods on semi landmarls will soon be.

First, let's have a look to graphics facilities
```{r, message=FALSE}
stack(wings)
w.al <- fgProcrustes(wings)
stack(w.al)
ldk_confell(w.al$coo, col = "red")
ldk_chull(w.al$coo)
ldk_contour(w.al$coo)
ldk_labels(mshapes(w.al$coo))
```

Multivariate methods are called using the same grammar
```{r, eval=FALSE}
w.p <- PCA(w.al)
plot(w.p, "group", 
     chull=TRUE, ellipsesax = FALSE, pos.shp = "full_axes", pch=20)

LDA(w.p, "group") %T>% plot_CV()
```

## Handling objects
One common yet boring task of morphometrics consists in handling datasets: add new information, remove some individuals, etc.

Momocs adapts [dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) verbs to its objects, and add new ones. If you have never heard of dplyr, let's have a look to this [introduction](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html), this may change your (R) life.

Basics verbs are implemented; try the following:
```{r}
data(olea)
olea

# slice: select individuals based on their position
slice(olea, 1:5)
slice(olea, -(1:100))

# filter: select individual based on a logical condition
filter(olea, domes=="cult", view!="VD")

# select: pick, reorder columns from the $fac
select(olea, 1, Ind=ind)

# rename: rename columns (select can also do it)
rename(olea, domesticated=domes)

# mutate: add new columns
mutate(olea, fake=factor(rep(letters[1:2], each=105)))

# transmute: add new columns and drop others
transmute(olea, fake=factor(rep(letters[1:2], each=105)))
```

And you can pipe those operations: say, we only want dorsal views from domesticated individuals, for a (renamed) 'status' column, and drop the 'ind' column:
```{r}
olea %>% 
  filter(domes=="cult", view=="VD") %>% 
  rename(domesticated=domes) %>% 
  select(-ind)
```

This should save some headaches.

New verbs are implemented: for instance, you can `chop` (a rougher slicing) according to a condition: this will create a list, on which you can apply further operations, then `combine` it back. This is particularly useful when you want to apply independant treatments to different partitions, eg orthogonal views of your model. Prior to this, we can use `table` to cross-tabulate data from `$fac`. We could have done the first step of what follows with `rm_uncomplete` that drops (if any) missing data.

```{r}
table(olea, "view", "var") # no VL for 'Cypre' var
olea %>% filter(var != "Cypre") %>%              # we drop 'Cypre'
  chop(view) %>% lapply(opoly) %>% combine() %>% # split, do morphometrics, combine
  PCA() %>% plot("var")                          # note the two views in the morphospace
```

Finally, several shortcuts are implemented on `Coo` and `Coe` objects:
* `names` returns shape names;
* `length` returns their number;
* `table` cross-tabulates the`$fac` component;
* `[]` extracts one (or more) shape;
* `$` can access either a shape name or a column name for the `$fac`.

Try the following:
```{r, eval=FALSE}
names(bot)
length(bot)
table(olea, "var", "domes")
bot[1]
bot[1:5]
bot$brahma
bot$type
```

## Babel import/export
__Work in progress__
There are various morphometrics formats in the wild, almost as much as softwares. Momocs tries to create bridges between them, all gathered in the **Babel** family. See `?Babel` for a full list.

### Within R
You can convert from/to array, matrix, list or data.frame with the functions `{a, m, l, d}2{a, m, l, d}`. For instance, `l2a` converts a list into an array that you can use with `geomorph`; `a2l` does the inverse operation

Imagine you want to import pupfish from `geomorph` as a `Ldk` object:

```{r}
library(geomorph)
data(pupfish)
str(pupfish)
# so $coords will become $coo, and
# all other components will be turned into a data.frame to feed $fac
# with a single line
Ldk(coo=pupfish$coords %>% a2l,
    fac=pupfish[-1] %>% as.data.frame())
```

### Save from R
The best way to save a Momocs object is probably to use the base `save` function. You can call it back afterwards with `load`:

```{r}
save(bot, file="Bottles.rda")
# closing R, going to the beach, back at work
load("Bottles.rda") # bot is back
```

### Export from R
Any Momocs object, `Coo`s, `Coe`s, `PCA`s, etc. can be turned into a `data.frame` with `as_df`. Work with `dplyr`, `ggplot2` is made easy and you can export it as `.txt`, `.csv` "by hand" or use the `export` function:

```{r, eval=FALSE}
bot %>% as_df # then %>% write.table
bot %>% efourier %>% export
bot %>% efourier %>% PCA %>% export
```

### Import in R
__Work in progress__

* `.tps` files can be read with `tps2Coo`
* `.nts` files an be read with `nts2Coo`

These functions are preliminary work since I do not use myself these formats. `readland.tps` and `readland.nts`, from the package `geomorph` by Adams, Collyer and Sherratt do a far better job.

## Graphics
__Work in progress__
If you prefer [ggplot2](http://ggplot2.org/) graphics. Have a look to `as_df` methods.
```{r}
library(ggplot2)
ggplot(m2d(shp), aes(x, y)) + geom_path() + coord_equal() + labs(title="A shape")
````

