---
title: "Operations on coordinates"
author: "Vincent Bonhomme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{03 - Operation on coordinates}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

Shapes are primarily $(x; y)$ coordinates on which we can apply transformations, *e.g.* centering, scaling, translate, etc.

Momocs comes with a large family of such transformations and this vignette aims at presenting them extensively. They are gathered in the topic **ShapeUtilities** in the manual.

Most examples below are self-explanatory but a full documentation can be found in their respective helpfiles (*e.g.* `coo.smooth`). When it makes sense to have a custom use of one of these operations, it is usually available as an argument.

The last sections show how to write your own transformation and how to apply them on `Out` objects. Handling of these classes and Global shape descriptors are described in their own vignettes.

# List of operations

We first load a cat and we call it `shp`. You can work on a different shape by changing this.

```{r}
library(Momocs)
data(shapes)
shp <- shapes[4] #try shapes[20] if you like Monty Pythons
coo.plot(shp, main = "A cat")
```

Most of them are linear mapping that rely on transformation matrices. The dedicated [Wikipedia](http://en.wikipedia.org/wiki/Linear_map) page is your friend.

### Align
Here again, several options are available:

* `coo.align` uses the inertia axes of the shape
* `coo.alignxax` does the same job but also translate the shape on the x-axis
* `coo.aligncalliper` aligns the shape along its Feret's diameter (or calliper length) distance (usually on convex shapes and not on cats); 

```{r, fig.show='hold'} 
shp <- coo.sample(shp, 128)
coo.plot(coo.align(shp), main = "coo.align")
# Calliper length, we also add the corresponding length
coo.plot(feret <- coo.aligncalliper(shp), main="coo.aligncalliper")
feretxy <- coo.calliper(shp, arr.ind = TRUE)$arr.ind
segments(feret[feretxy[1], 1], feret[feretxy[1], 2],
         feret[feretxy[2], 1], feret[feretxy[2], 2], col="red")
coo.plot(coo.alignxax(shp), main="coo.alignxax")
```

### Center
Note the axis lines drawn by `coo.plot`.
```{r}
coo.plot(coo.center(shp), main="coo.center")
```

### Centroid related operations
To get the centroid position, the centroid size and the distance of every point to the centroid :
```{r}
# centroid position
centxy <- coo.centpos(shp) 
centxy
# the centroid size
coo.centsize(shp) 
# distance of the (first) points to the centroid
head(coo.centdist(shp)) 
```

### Baseline registration
Two options to register a baseline:
* `coo.bookstein` transforms the shape so that the specified points are on Bookstein's coordinates.
* `coo.baseline` is a generalization of the latter 
```{r, fig.show='hold'}
# Note the two baseline points
par(xpd=NA)
coo.plot(coo.baseline(shp, 17, 6, t1=c(-50, 0), t2=c(50, 0)), main="coo.baseline")
points(c(-50, 50), c(0, 0), col="red", pch=3)
coo.plot(coo.bookstein(shp, 17, 6), main="coo.bookstein")
points(c(-0.5, 0.5), c(0, 0), col="red", pch=3)
```

### Rotate
You can use:
* `coo.rotate` for a rotation centered on the origin
* `coo.rotatecenter` for a custom rotation

```{r, fig.show='hold'}
coo.plot(coo.rotate(shp, pi), main="coo.rotate")
coo.plot(coo.rotatecenter(shp, pi, center=c(25, 25)), main="coo.rotatecenter")
```

### Sample
Several options are available:
* `coo.sample` samples equidistant points along the curvilinear abscissa
* `coo.samplerr` with a regular angle between successive points (in polar coordinates)
* `coo.interpolate` is a (cheap) way to interpolate coordinates

```{r, fig.show='hold'}
# equidistant sampling along curvilinear abscissa
coo.plot(coo.sample(shp, 36), points=TRUE, main="coo.sample")
# regular angle
shp.rr <- coo.samplerr(shp, 36)
centxy <- coo.centpos(shp.rr)
coo.plot(shp.rr, main="coo.samplerr")
segments(centxy[1], centxy[2], shp.rr[, 1], shp.rr[, 2])
# interpolate
shp12 <- coo.sample(shp, 12)
coo.plot(shp12, pch=20, cex=2, main="coo.interpolate")
points(coo.interpolate(shp12, 36), pch=20, col="red")
```

### Scale
Two functions for (isotropic scaling):
* `coo.scale` for a classical scaling
* `coo.template` to inscribe a shape in a square
By default, the centroid size is used as a scaling factor.

```{r, fig.show='hold'}
coo.plot(shp)
coo.plot(coo.scale(shp))
```

But some exotic uses may require:
* `coo.scalex` for a scaling parallel to the x-axis
* `coo.scaley` its y-axis counterpar

```{r, fig.show='hold'}
shp.c <- coo.center(shp)
coo.plot(shp.c)
coo.draw(coo.scalex(shp.c, 1/3), main="coo.scalex")
coo.plot(shp.c)
coo.draw(coo.scaley(shp.c, 1/3), main="coo.scaley")
```

### Shear
Again, two functions:
* `coo.shearx` for an x-shear mapping
* `coo.sheary` same thing for y

```{r, fig.show='hold'}
coo.plot(coo.shearx(shp.c, 0.5), main="coo.shearx")
coo.plot(coo.sheary(shp.c, 1.2), main="coo.sheary")
```

### Slide
Two function to change the order of points:
* `coo.slide` if you know which point should be the first
* `coo.slidedirection` if it makes sense to use one particular direction

```{r, fig.show='hold'}
coo.plot(shp)
coo.plot(coo.slide(shp, 94)) # note the nose
coo.plot(coo.slidedirection(shp, direction = "N"), main="N")
coo.plot(coo.slidedirection(shp, direction = "W"), main="W")
coo.plot(coo.slidedirection(shp, direction = "S"), main="S")
coo.plot(coo.slidedirection(shp, direction = "E"), main="E")
```

### Smooth
Use `coo.smooth`and its mobile average. 
```{r, fig.show='hide'}
coo.plot(shp)
for (i in c(10, 50, 200)) coo.plot(coo.smooth(shp, i))
```
If you work with open outlines, `coo.smoothcurve` will preserve ending points.

### Translate
`coo.trans` is your friend.

```{r}
coo.plot(shp)
for (i in seq(0, 100, 20)) coo.draw(coo.trans(shp, i))
```

### Exotic functions
I do not really know how to class these functions 
* `coo.close` (and `coo.unclose`) to (un)close shapes
* `coo.chull` a wrapper around chull to draw convex hulls
* `coo.check` is a (rather open-minded so far) shape checker
* `coo.up` (and `coo.down`) to retains points with above (below) x-axis

```{r, fig.show='hide'}
coo.plot(shp)
coo.draw(coo.close(coo.chull(shp)), border="red")
shp.c <- coo.center(shp)
coo.plot(shp.up <- coo.up(shp.c), points=TRUE)
coo.plot(coo.down(shp.c), points=TRUE) # you may also need coo.slide
coo.plot(coo.rev(shp.up)) # now counter-clockwise
```

# One step further
## Combine operations
Operations can be combined *ad infinitum*, for instance for centering and scaling.
```{r}
coo.plot(coo.center(coo.scale(shp)))
```

You could write your own function to do that (or anything else)
```{r, eval=FALSE}
coo.cs <- function(coo){
  return(coo.center(coo.scale(coo)))}
coo.plot(coo.cs) # try that
```
Or even [maggritr](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)-style with:
```{r, eval=FALSE}
library(magrittr)
coo.cs2 <- function(coo) coo %>% coo.scale %>% coo.center
coo.plot(coo.cs2(shp))
```

## Apply operations on Coo objects

The most commonly used functions also have the corresponding methods to work on `Coo` objects (`Out`, `Opn`, `Ldk`). 

For instance, let's center some bottles:

```{r, fig.show='hold'}
data(bot)
stack(bot)
bot.c <- coo.center(bot)
stack(bot.c)
```

You can also write your own operation on `Coo` objects by modifying the `$coo` component. Most of the time it will be the only one that needs to be changed.

```{r}
bot.cs <- bot.c # we make a 'copy'
bot.cs$coo <- lapply(bot.cs$coo, function(x) coo.center(coo.scale(x)))
stack(bot.cs)
```






