---
title: "Technical details"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Technical details}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE}
library(knitr)
library(Momocs)

tab_met <- function(l){
  met <- lapply(l, function(x) {
    m <- methods(class=x)
    m <- substr(m, 1, nchar(m) - nchar(x) - 1)})
  all <- sort(unique(unlist(met)))
  tab <- matrix("" , nrow=length(all), ncol=length(l),
                dimnames=list(all, l))
  avail <- lapply(met, function(x) match(x, all))
  for (i in 1:length(avail)) {
    tab[avail[[i]], i] <- "X"
  }
  as.table(tab)}


tab_args <- function(l){
  met <- lapply(l, function(x) names(as.list(args(x))))
  all <- sort(unique(unlist(met)))
  tab <- matrix(NA, nrow=length(all), ncol=length(l),
                dimnames=list(all, l))
  avail <- lapply(met, function(x) match(x, all))
  for (i in 1:length(avail)) {
    tab[avail[[i]], i] <- "X"
  }
  as.table(tab)}

mc <- function(class){
  x <- methods(class = class)
  x <- substr(x, 1, nchar(x)-nchar(class)-1)
  x <- c(" ", x )
  cat(x, sep = "\n * ")
}


```
# Preamble
* This document is intended to provide technical details behind the curtain.
* It also helps me to fill the gaps and as a development map.
* If it is your first contact with Momocs, you'd rather use the other vignette "Introduction to Momocs"

## Architecture

And uses this vocabulary :

* A *shape* is an ordinate set (id varies from 1 to shape_length) of 2D (so far) coordinates
* `Coo`rdinates are shapes + (classifiers and/or covariates) + hypotheses + questions.
* `Coo` objects are turned into `Coe`fficients with appropriate morphometric methods, and on which to apply multivariate analyses.
* A lot of intermediate steps can, and usually *shoud*, be done.
* Graphically, this can be represented as:
![architecture](MomocsArch.png)


# Classes and methods

Morphometrics is the statistical description of shapes, in other words methods that turn $(x, y)$ coordinates into quantitative variables.

Of course, the raw data may differ in their nature: outlines, curves, configuration of landmarks, and once you have quantitative variables you have a bunch of multivariate analyses at your fingertips.

Whatever the morphometric approach you are using (say outline analysis) you have very *generic* needs that you share with other approaches (say configuration of landmarks), for instance centering and plotting your shape dataset. But you have have very *specific* needs, for instance calculation Elliptical Fourier Transform, which makes no sense on configuration of landmarks.

Momocs use a simple scheme of classes to handle the different morphometrics approaches and the methods associated with:

* **Coo**rdinates are primarily `Coo` objects but also of class:
    + `Out` for **out**lines
    + `Opn` for **op**e**n** outlines
    + `Ldk` for configurations of **l**an**d**mar**k**s
* **Coe**fficients are primarily `Coe` objects but also of class:
    + `OutCoe`
    + `OpnCoe`
    + `LdkCoe`
    
They are all described in their own helpfiles (*e.g.* `?Out`).
* To see attached methods, eg for `OpnCoe` : `methods(class = "OpnCoe")`
* To see R code behind methods, eg for `hist.OpnCoe` : `Momocs:::hist.OpnCoe`
* Constructors are available, eg `Out()`

## `Coo` class : coordinates
`Coo` classes share most of their slots :

`Coo`         | `Out` | `Opn` | `Ldk` | |
------        |  ---  | ---   | ---   | ----
`$coo`        | X     | X     | X     | list of matrices of coordinates
`$fac`        | x     | x     | x     | data.frame of factors and covariable
`$ldk`        | x     | x     | _     | list of numeric of the ids of the landmarks
`$baseline`   | _     | x     | _     | list of baseline coordinates
`$sliding`    | _     | _     | x     | list of the ids of the sliding landmarks
`$links`      | _     | _     | x     | matrix of links between landmarks

* `X` denotes mandatory information, `x` optionnal, `-` not available.

## From `Coo` to `Coe`: morphometric methods
Here are the methods implemented for every class that can be applied on the proper `Coo` object, and they create the proper `Coe` object.

Coo           | method name     | what
--------------| --------------- | --------------
`Out`         | `efourier`      | Elliptical Fourier Transforms
 _            | `rfourier`      | Radii variation Fourier Transforms
 _            | `tfourier`      | Tangent angle Fourier Transforms
`Opn`         | `npoly`         | Natural polynomial fit
 _            | `opoly`         | Orthogonal polynomial fit
 _            | `dfourier`      | Discrete Cosinus Transform [planned]
 `Ldk`        | `fproc`         | Full Procrustes Superimposition [planned]
_             | `fgproc`        | Full Generalized Procrustes [planned]
_             | _               | Both Procrustes with robust / sliding handling

The same method can also be called on single shapes: eg `efourier(bot[1])`.

## `Coe` class : morphometric coefficients
For `$Coe`, we change the `$coo` for `$coe` and we add a `$method` :

`Coe`         | `Out` | `Opn` | `Ldk` | |
------        |  ---  | ---   | ---   | ----
`$coe`        | X     | X     | X     | matrix of coefficients
`$fac`        | x     | x     | x     | data.frame of factors and covariable
`$ldk`        | x     | x     | _     | list of numeric of the ids of the landmarks
`$baseline`   | _     | x     | _     | list of baseline coordinates
`$sliding`    | _     | _     | x     | list of the ids of the sliding landmarks
`$method`     | x     | x     | x     | details of the morphometric

## Handling classes
* `Coo` objects can be indiced and return the corresponding shape, eg `bot[5]`
* `Coo` and `Coe` objects can be subsetted using `subset` (see `subset.Coo`)
* Similarly, they can be combined using `combine` (see `?combine`)
* Different `Coo` objects can be combined (eg. open and closed outlines)

## `Coo`, `Out`, `Opn`, `Ldk` methods
Methods defined on `Coo` apply to all classes.

```{r, results='markup', echo=-1}
kable(tab_met(c("Coo", "Out", "Opn", "Ldk")))
```

## `Coe`, `OutCoe`,  `OpnCoe`, `LdkCoe` methods
Methods defined on `Coe` apply to all classes.
```{r, results='markup', echo=-1}
kable(tab_met(c("Coe", "OutCoe", "OpnCoe", "LdkCoe")))
```

# Various
## Naming conventions
Momocs uses the following naming conventions :

Pattern       | What                      | Example
------------- | ------------------------- | ----------
`[A-Z][a-z]`  | Class                     | `Out`
`[A-Z]+`      | Multivariate method       | `PCA`
`*.*`         | Methods or arguments      | `PCA.LDA` and `nb.pts`
`coo_*`       | Operations on coordinates | `coo_sample`
`.*`          | Internal functions        | `.trim.path`

## Import data

Raw data can be imported :

What    | From | With
------  | -----| -----
extract outline coordinates from segmented images | `.jpg` | `import_jpg`
any other coordinates | `.txt` | `import_txt`

Other morphometric formats can be imported with :

What    |  To     | With
------  | -----   | -----
tps     | `Coo`   | `tps2Coo` 
chc     | `Out`   | `chc2Out`

Bridges from other morphometric formats are quite experimental. Contact me should you have any problem, need something.

Open-source softwares such as [Gimp](http://www.gimp.org/), to prepare images, and [ImageJ](http://imagej.nih.gov/ij/) to extract coordinates/landmarks/etc. to text files.


## Operations on coordinates
* They are named with the pattern : `coo_something`
* All of them apply on shapes but the most common operations have a `Coo` method:

Function        | What (single shapes or  any `Coo`)
--------------- | ---------------
coo_center      | center shape(s)
coo_scale       | scale shape(s)
coo_align       | align shape(s) (other options available)
coo_sample      | sample shape(s) (other options available)
coo_smooth      | smooth shape(s) (other options available)

* To get the full list all : ```ls("package=Momocs, pattern = "coo-")```


## Graphics
* `img_plot`and `img_plot0` : two jpg plotters
* `coo_plot` a shape plotter
* `stack` all shapes from any `Coo` object on the same plane
* `panel` a family picture any `Coo` object
* `hist` and `boxplot` on `Coe` objects
* `plot` plots a particular shape from a `Coo` object
* `plot` and `boxplot` methods for PCA, LDA (and more to come) have many options, notably plotting morphospaces.
* `plotCV` and `plotCV2` for cross-validation table on `LDA` objects
* Thin plate splines are available in different flavors (see `?tps.arr` and others)
* Note that in a future version, all graphics will be converted to their ggplot2 equivalent, and graphics methods will return a ggplot object.

## Datasets
The following datasets are bundled with Momocs :

```{r, results='asis', echo=FALSE}
p <- data(package = "Momocs")$results[, -(1:2)]
p[, 2] <- substr(p[, 2], 7, nchar(p[, 2]))
colnames(p) <- c("Name", "Description")
knitr::kable(p)
```

* Each of them can be called with, eg : `data(bot)`
* Details, credits and analyses examples can be found in their respective helpfiles, eg. `?bot`
* Help it grow by sending me your published data !

## Multivariate analyses
Method       | What
-------      | ---------
`PCA`        | Principal Component Analysis
`LDA`        | Linear Discriminant Analysis (+ CV leave-one-out)
`RDA`        | Redundancy analysis [planned]
`CLUST`      | Hierarchical clustering
`MANOVA`     | Multivariate analysis of variance
`MANOVA_PW`  | Pairwise Multivariate analysis of variance
`LM`         | Multivariate regression [planned]

* When possible, methods apply directly on the corresponding `Coe` object.
* Otherwise, a dimensionnality reduction with `PCA`, then doing the analysis on the `PCA` object will be prefered/required.

```{r, results='markup', echo=-1}
kable(tab_met(c("PCA", "LDA")))
```

## Global shape descriptors
The following list of global shape descriptors is available :

Function                          | What
---------------------             | -------------------
coo_perim                         | perimeter 
coo_area                          | area
coo_calliper                      | calliper length
coo_length                        | length
coo_width                         | width
coo_circularity                   | circularity
coo_circularityharalick           | Haralick's circularity
coo_circularitynorm               | compactness
coo_convexity                     | convexity
coo_eccentricityboundingbox       | eccentricity using a bounding box
coo_eccentricityeigen             | eccentricity using inertia axes
coo_elongation                    | elongation
coo_rectangularity                | rectangularity
coo_rectilinearity                | rectilinearity
coo_solidity                      | solidity

* They can be used like that :
```{r, eval=FALSE}
res <- sapply(bot$coo,function(x)
        c(coo_width(x), coo_length(x), coo_elongation(x)))
# etc., eg :
pairs(t(res))
resp <- PCA(t(res), fac=bot$fac)
```



