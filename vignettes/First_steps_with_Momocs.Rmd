---
title: "Technical details"
author: "Vincent Bonhomme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Technical details}
  \usepackage[utf8]{inputenc}

---

```{r, echo=FALSE}
library("knitr")
library(Momocs)

library(Momocs)

tab_met <- function(l){
  met <- lapply(l, function(x) {
    m <- methods(class=x)
    m <- substr(m, 1, nchar(m) - nchar(x) - 1)})
  all <- sort(unique(unlist(met)))
  tab <- matrix("" , nrow=length(all), ncol=length(l),
                dimnames=list(all, l))
  avail <- lapply(met, function(x) match(x, all))
  for (i in 1:length(avail)) {
    tab[avail[[i]], i] <- "X"
  }
  as.table(tab)}


tab_args <- function(l){
  met <- lapply(l, function(x) names(as.list(args(x))))
  all <- sort(unique(unlist(met)))
  tab <- matrix(NA, nrow=length(all), ncol=length(l),
                dimnames=list(all, l))
  avail <- lapply(met, function(x) match(x, all))
  for (i in 1:length(avail)) {
    tab[avail[[i]], i] <- "X"
  }
  as.table(tab)}

mc <- function(class){
  x <- methods(class = class)
  x <- substr(x, 1, nchar(x)-nchar(class)-1)
  x <- c(" ", x )
  cat(x, sep = "\n * ")
}


```


# Preamble
## About
* Momocs is a work in progress.
* The last stable version is released on [CRAN](http://cran.r-project.org/web/packages/Momocs/index.html).
* The last version is on [GitHub](https://github.com/vbonhomme/Momocs) and you should use it.
* If you use it, please cite it: `citation("Momocs")`. A second paper is in prep.

## Assumptions
Momocs makes the following assumptions:

* You have a basic knowledge of R
* You know what you want to do in statistics / morphometrics terms

## Aims
Overall, long-term goals are :

* Gather all morphometrics in a single grammar
* Brige morphometrics softwares and analyses
* Easy to use/extend
* Delicious hackable graphics

## Help
* Tutorial are on their way `?Momocs`.
* You can collaborate to Momocs' development using GitHub. This is also the preferred place for bug reports. If you're not familiar with it, contact me directly.
* I welcome bug reports, suggestions, data, questions, collaborations requests, etc. `bonhomme.vincent@gmail.com`. Your help will be duly credited.


## Conventions
* A *shape* is an ordinate set (id varies from 1 to shape_length) of 2D (so far) coordinates
* `Coo`rdinates are shapes + (classifiers and/or covariates) + hypotheses + questions.
* `Coo` objects are turned into `Coe`fficients with appropriate morphometric methods, and on which to apply multivariate analyses.
* A lot of intermediate steps can, and usually *shoud*, be done.
* Graphically, this can be represented as:
![architecture](MomocsArch.png)

Momocs uses the following naming conventions :

Pattern       | What                      | Example
------------- | ------------------------- | ----------
`[A-Z][a-z]`  | Class                     | `Out`
`[A-Z]+`      | Multivariate method       | `PCA`
`*.*`         | Methods or arguments      | `PCA.LDA` and `nb.pts`
`coo_*`       | Operations on coordinates | `coo_sample`
`.*`          | Internal functions        | `.trim.path`


# Using Momocs
## Import data

Raw data can be imported :

What    | From | With
------  | -----| -----
extract outline coordinates from segmented images | `.jpg` | `import_jpg`
any other coordinates | `.txt` | `import_txt`

Other morphometric formats can be imported with :

What    |  To     | With
------  | -----   | -----
tps     | `Coo`   | `tps2Coo` 
chc     | `Out`   | `chc2Out`

Bridges from other morphometric formats are quite experimental. Contact me should you have any problem, need something.

Open-source softwares such as [Gimp](http://www.gimp.org/), to prepare images, and [ImageJ](http://imagej.nih.gov/ij/) to extract coordinates/landmarks/etc. to text files.


## Operations on coordinates
* They are named with the pattern : `coo_something`
* All of them apply on shapes but the most common operations have a `Coo` method:

Function        | What (single shapes or  any `Coo`)
--------------- | ---------------
coo_center      | center shape(s)
coo_scale       | scale shape(s)
coo_align       | align shape(s) (other options available)
coo_sample      | sample shape(s) (other options available)
coo_smooth      | smooth shape(s) (other options available)

* To get the full list all : ```ls("package=Momocs, pattern = "coo-")```

## Classes
* Momocs defines and uses S3 classes. Not the most rigorous but familiar to most of us.
* `Coo`rdinates -> Morphometrics -> `Coe`fficients.
* `Coo` and `Coe` are "super-classes" for coordinates and coefficients.
* Only appropriate morphometrics are allowed on each class and turn :
    + `Out` for closed outlines, into `OutCoe`;
    + `Opn` for open curves, into `OpnCoe`;
    + `Ldk` for landmarks, into `LdkCoe`.
* To see class definitions, eg `Out` : `?Out`.
* To see attached methods, eg for `OpnCoe` : `methods(class = "OpnCoe")`
* To see R code behind methods, eg for `hist.OpnCoe` : `Momocs:::hist.OpnCoe`
* Constructors are available, eg `Out()`

### `Coo` class : coordinates
`Coo` classes share most of their slots :

`Coo`         | `Out` | `Opn` | `Ldk` | |
------        |  ---  | ---   | ---   | ----
`$coo`        | X     | X     | X     | list of matrices of coordinates
`$fac`        | x     | x     | x     | data.frame of factors and covariable
`$ldk`        | x     | x     | _     | list of numeric of the ids of the landmarks
`$baseline`   | _     | x     | _     | list of baseline coordinates
`$sliding`    | _     | _     | x     | list of the ids of the sliding landmarks
`$links`      | _     | _     | x     | matrix of links between landmarks

* `X` denotes mandatory information, `x` optionnal, `-` not available.

### From `Coo` to `Coe`: morphometric methods
Here are the methods implemented for every class that can be applied on the proper `Coo` object, and they create the proper `Coe` object.

Coo           | method name     | what
--------------| --------------- | --------------
`Out`         | `efourier`      | Elliptical Fourier Transforms
 _            | `rfourier`      | Radii variation Fourier Transforms
 _            | `tfourier`      | Tangent angle Fourier Transforms
`Opn`         | `npoly`         | Natural polynomial fit
 _            | `opoly`         | Orthogonal polynomial fit
 _            | `dfourier`      | Discrete Cosinus Transform [planned]
 `Ldk`        | `fproc`         | Full Procrustes Superimposition [planned]
_             | `fgproc`        | Full Generalized Procrustes [planned]
_             | _               | Both Procrustes with robust / sliding handling

The same method can also be called on single shapes: eg `efourier(bot[1])`.

### `Coe` class : morphometric coefficients
For `$Coe`, we change the `$coo` for `$coe` and we add a `$method` :

`Coe`         | `Out` | `Opn` | `Ldk` | |
------        |  ---  | ---   | ---   | ----
`$coe`        | X     | X     | X     | matrix of coefficients
`$fac`        | x     | x     | x     | data.frame of factors and covariable
`$ldk`        | x     | x     | _     | list of numeric of the ids of the landmarks
`$baseline`   | _     | x     | _     | list of baseline coordinates
`$sliding`    | _     | _     | x     | list of the ids of the sliding landmarks
`$method`     | x     | x     | x     | details of the morphometric

### Handling classes
* `Coo` objects can be indiced and return the corresponding shape, eg `bot[5]`
* `Coo` and `Coe` objects can be subsetted using `subset` (see `subset.Coo`)
* Similarly, they can be combined using `combine` (see `?combine`)
* Different `Coo` objects can be combined (eg. open and closed outlines)

## Multivariate analyses
Method       | What
-------      | ---------
`PCA`        | Principal Component Analysis
`LDA`        | Linear Discriminant Analysis (+ CV leave-one-out)
`RDA`        | Redundancy analysis [planned]
`CLUST`      | Hierarchical clustering
`MANOVA`     | Multivariate analysis of variance
`MANOVA_PW`  | Pairwise Multivariate analysis of variance
`LM`         | Multivariate regression [planned]

* When possible, methods apply directly on the corresponding `Coe` object.
* Otherwise, a dimensionnality reduction with `PCA`, then doing the analysis on the `PCA` object will be prefered/required.

## Graphics
* `img_plot`and `img_plot0` : two jpg plotters
* `coo_plot` a shape plotter
* `stack` all shapes from any `Coo` object on the same plane
* `panel` a family picture any `Coo` object
* `hist` and `boxplot` on `Coe` objects
* `plot` plots a particular shape from a `Coo` object
* `plot` and `boxplot` methods for PCA, LDA (and more to come) have many options, notably plotting morphospaces.
* `plotCV` and `plotCV2` for cross-validation table on `LDA` objects
* Thin plate splines are available in different flavors (see `?tps.arr` and others)
* Note that in a future version, all graphics will be converted to their ggplot2 equivalent, and graphics methods will return a ggplot object.

## Datasets
The following datasets are bundled with Momocs :

```{r, results='asis', echo=FALSE}
p <- data(package = "Momocs")$results[, -(1:2)]
p[, 2] <- substr(p[, 2], 7, nchar(p[, 2]))
colnames(p) <- c("Name", "Description")
knitr::kable(p)
```

* Each of them can be called with, eg : `data(bot)`
* Details, credits and analyses examples can be found in their respective helpfiles, eg. `?bot`
* Help it grow by sending me your published data !

# Method-dependent tools

## Outline analysis
* Procrustes alignment can be used either on landmarks, previously defined with `def_ldk`, on on all coordinates. Then you will probably need to redefine the first point (see `coo_slide` and `coo_slidedirection`)
* `cal_d`, `cal_e`, `cal_p` and `cal_v` for calibration using distances, error estimation between two sets, (harmonic) power, visual reconstruction.
* `rm_Sym` and `rm_Asym` remove a/symmetric components for EFT

## Open outlines
* `cal_d`, `cal_e`, `cal_p` and `cal_v` for calibration using distances, error estimation between two sets, (harmonic) power, visual reconstruction.

## Configuration of landmarks
* defining landmarks/links
* alignment

## Traditional morphometrics
* On its way into the integration.

## Global shape descriptors
The following list of global shape descriptors is available :

Function                          | What
---------------------             | -------------------
coo_perim                         | perimeter 
coo_area                          | area
coo_calliper                      | calliper length
coo_length                        | length
coo_width                         | width
coo_circularity                   | circularity
coo_circularityharalick           | Haralick's circularity
coo_circularitynorm               | compactness
coo_convexity                     | convexity
coo_eccentricityboundingbox       | eccentricity using a bounding box
coo_eccentricityeigen             | eccentricity using inertia axes
coo_elongation                    | elongation
coo_rectangularity                | rectangularity
coo_rectilinearity                | rectilinearity
coo_solidity                      | solidity

* They can be used like that :
```{r, eval=FALSE}
res <- sapply(bot$coo,function(x)
        c(coo_width(x), coo_length(x), coo_elongation(x)))
# etc., eg :
pairs(t(res))
resp <- PCA(t(res), fac=bot$fac)
```

## List of methods by class

### `Out`, `Opn`, `Ldk`
```{r, results='markup', echo=-1}
kable(tab_met(c("Out", "Opn", "Ldk")))
```

And methods defined directly on `Coo` are also available:
```{r, results='markup', echo=-1}
kable(tab_met(c("Coo")))
```


### `OutCoe`,  `OpnCoe`, `LdkCoe`
```{r, results='markup', echo=-1}
kable(tab_met(c("OutCoe", "OpnCoe", "LdkCoe")))
```

And methods defined directly on `Coe` are also available:
```{r, results='markup', echo=-1}
kable(tab_met(c("Coe")))
```

### Multivariate analyses
```{r, results='markup', echo=-1}
kable(tab_met(c("PCA", "LDA")))
```

# Todo
* hcontrib devient coeff_contrib (Out, Opn)
* mshapes + mshape
* fProcrustes devient fproc
* fgproc : écrire
* calibrate_ retourne res + Out

